{"version":3,"file":"index.browser.min.js","sources":["../src/utils/assertBrowserEnviroment.js","../src/stream.js","../src/utils/assertEventTarget.js","../src/dispatch.js","../src/receive.js"],"sourcesContent":["/** @format */\n\n/**\n * Utility method to assert the given enviroment. Stræm will only work in a browser enviroment.\n * While node does implement a EventTarget interface, it does not work like the browser one.\n *\n * @returns { boolean } true / false depeding on the assert result\n */\n\nexport const assertBrowserEnviroment = () =>\n  !(typeof process === \"object\" && String(process) === \"[object process]\");\n","/** @format */\n\nimport { assertBrowserEnviroment } from \"./utils/assertBrowserEnviroment.js\";\nimport { assertEventTarget } from \"./utils/assertEventTarget\";\n\nexport const stream = () => {\n  /**\n   * Run a enviroment test to assert that the enviroment is a browser, as stream will not work\n   * in a node enviroment.\n   */\n\n  if (!assertBrowserEnviroment()) {\n    throw new Error(\n      `Stream: Stream is only available in a browser enviroment.`\n    );\n  }\n\n  // set the eventTarget property to window by default to ensure that a valid target exists\n\n  let eventTarget = window;\n\n  return {\n    /**\n     * The intended eventTarget existing on the dispatcher/listener.\n     * @type { EventTarget }\n     */\n\n    eventTarget,\n\n    /**\n     * Method to set the eventTarget for the dispatcher/listener.\n     *\n     * @param { EventTarget } eventTarget - the supposed eventTarget that should be used to create the\n     * listener/dispatcher.\n     *\n     * @returns { { eventNames: string[], eventTarget: EventTarget, with: function, from: function  then: function} }\n     * an object containing the eventName/s, eventTarget, the 'from()' method to set the eventTarget and the the\n     * 'with()' method to dispatch the event with a given payload or the 'then()' method to execute a callback,\n     * depending on if the from method was called by the dispatch or receive method.\n     */\n\n    from(eventTarget) {\n      // Check if the passed target is a valid EventTarget instance and throw a TypeError if not,\n      // to ensure that the 'with' method receives a valid target.\n      if (!assertEventTarget(eventTarget)) {\n        throw new TypeError(\n          `Stræem: ${target} is not a valid target for a receiving or dispatching events.`\n        );\n      }\n\n      this.eventTarget = eventTarget;\n      return this;\n    },\n  };\n};\n","/** @format */\n\n/**\n * Utility method to assert that a given element is a valid EventTarget instance. EventListeners/Dispatchers can\n * only be attached to EventTargets.\n *\n * @param { * } eventTarget - the proposed eventTarget that will be asserted\n * @returns { boolean } true / false depeding on the assert result\n */\n\nexport const assertEventTarget = (eventTarget) =>\n  eventTarget instanceof EventTarget;\n","/** @format */\n\nimport { stream } from \"./stream.js\";\n\n/**\n * The dispatch method is used to create and dispatch a CustomEvent.\n *\n * @param  {...string} eventNames - Any number of strings that describes the names of the\n * CustomEvents to dispatch.\n * @returns { { eventNames: string[], eventTarget: EventTarget, with: function, from: function } } an object\n * containing the eventName/s, eventTarget, the 'from()' method to set the eventTarget and the the 'with()'\n * method to dispatch the event with a given payload\n */\n\nexport const dispatch = (...eventNames) => {\n  return {\n    ...stream(),\n\n    /**\n     * The array of strings passed as eventNames\n     * @type { string[] }\n     */\n\n    eventNames,\n\n    /**\n     * Method to disptach the event with a give payload. A event will be dispatched for every eventName existing on the\n     * created dispatcher. The eventInit object is optional and is the same as a regular event.\n     *\n     * @param { *? } payload - The payload that will be created on the event.detail property.\n     * @param { {}? } eventInit - a eventInit object as described by the Event() interface.\n     */\n\n    with(payload = null, eventInit = {}) {\n      // Add the payload to the eventInit object.\n      eventInit.detail = payload;\n\n      eventNames.forEach((eventName) =>\n        this.eventTarget.dispatchEvent(new CustomEvent(eventName, eventInit))\n      );\n    },\n  };\n};\n","/** @format */\n\nimport { stream } from \"./stream.js\";\n\n/**\n * The receive method is used to create a custom eventListener.\n *\n * @param  {...string} eventNames - Any number of strings that describes the names of the\n * CustomEvents/Events to listen to.\n * @returns { { eventNames: string[], eventTarget: EventTarget, with: function, then: function } } an object\n * containing the eventName/s, eventTarget, the 'from()' method to set the eventTarget and the the 'then()'\n * method to execute a given callback when the event is received.\n */\n\nexport const receive = (...eventNames) => {\n  return {\n    ...stream(),\n\n    /**\n     * The array of strings passed as eventNames\n     * @type { string[] }\n     */\n\n    eventNames,\n\n    /**\n     * Method to set the callback and options for the EventListener for the given eventTarget.\n     *\n     * @param { function(Event) } eventHandler - the function to call when a event is received. The handler will\n     * receive the Event as argument.\n     * @param { {}? } options - a optional options object to pass to the listener. Implements the same interface as\n     * a regular eventListener\n     *\n     * @returns { function } a function to remove all created eventListeners\n     */\n\n    then(eventHandler, options) {\n      const handler = (ev) => eventHandler(ev);\n\n      eventNames.forEach((eventName) =>\n        this.eventTarget.addEventListener(eventName, handler, options)\n      );\n\n      return () => {\n        eventNames.forEach((eventName) =>\n          this.eventTarget.removeEventListener(eventName, handler, options)\n        );\n      };\n    },\n  };\n};\n"],"names":["stream","process","String","Error","eventTarget","window","from","EventTarget","assertEventTarget","TypeError","target","this","eventNames","with","payload","eventInit","detail","forEach","eventName","dispatchEvent","CustomEvent","then","eventHandler","options","handler","ev","addEventListener","removeEventListener"],"mappings":"oCASO,MCJMA,EAAS,KAMpB,GDDqB,iBAAZC,SAA4C,qBAApBC,OAAOD,SCEtC,MAAM,IAAIE,MACR,6DAQJ,MAAO,CAMLC,YARgBC,OAsBhBC,KAAKF,GAGH,IClC2B,CAACA,GAChCA,aAAuBG,YDiCdC,CAAkBJ,GACrB,MAAM,IAAIK,UACR,WAAWC,uEAKf,OADAC,KAAKP,YAAcA,EACZO,0BErCW,IAAIC,KACnB,IACFZ,IAOHY,WAAAA,EAUAC,KAAKC,EAAU,KAAMC,EAAY,IAE/BA,EAAUC,OAASF,EAEnBF,EAAWK,SAASC,GAClBP,KAAKP,YAAYe,cAAc,IAAIC,YAAYF,EAAWH,mBCxB3C,IAAIH,KAClB,IACFZ,IAOHY,WAAAA,EAaAS,KAAKC,EAAcC,GACjB,MAAMC,EAAWC,GAAOH,EAAaG,GAMrC,OAJAb,EAAWK,SAASC,GAClBP,KAAKP,YAAYsB,iBAAiBR,EAAWM,EAASD,KAGjD,KACLX,EAAWK,SAASC,GAClBP,KAAKP,YAAYuB,oBAAoBT,EAAWM,EAASD"}